# 4.锁的优化及注意事项

#### <1>减少锁持有的时间
只在必要的地方进行加锁
例如:<br>
```
public synchronized void syncMethod(){
    othercode1();
    mutexMethod();
    othercode2();
}
```

替换为
```
public void syncMethod2(){
    othercode1();
    synchronized(this){
        mutexMethod();
    }
    othercode2();
}
```
#### <2>减小锁粒度
典型场景是`ConcurrentHashMap` 对于`HashMap`来说，最重要的两个方法就是`get()`和`set()` 一种最自然的想法就是，
对整个`HashMap`枷锁从而得到一个线程安全的对象，但是这样做，枷锁粒度太大。对于`ConcurrentHashMap`类，它内部进一步细分了
若干个小的`HashMap`，称之为段（`SEGMENT`）。在默认情况下，一个`ConcurrentHashMap`类可以被细分为16个段.<br>
如果需要在`ConcurrentHashMap`类中增加一个新的表项，并不是将整个`HashMap`枷锁，而是首先根据`hascode`得到该表项应该被
存放在哪个段红，然后对该段枷锁，并完成`put()`方法.<br>
  但是，减小锁粒度会带来一个新的问题，即当系统需要取得全局锁时，其消耗的资源会比较多.比如执行`size()`方法时，会对所有段进行加锁
然后算size，然后释放锁.<br>
事实上，`ConcurrentHashMap`执行`size()`时，首先会进行无锁尝试获取，如果失败才会进行上诉操作.

#### <3>用读写分离锁来替换独占锁
  使用读写分离锁`ReadWriteLock`
  
#### <4>锁分离
  如果将读写锁的思想进一步延伸，就是锁分离。
  
#### <4>锁粗化
  通常情况下，为了保证多线程间的有效并发，会要求每个线程持有的锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。只有这样，等待在这个
锁上的其他线程才能尽早地获得资源执行任务。但是，凡事都有一个度，如果对同一个锁不停地进行请求、同步和释放，其本身也会消耗系统宝贵的资源，
反而不利于性能的优化。<br>
  为此，虚拟机在遇到一连串连续的对同一个锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，
这个操作叫做锁的粗化.
  
  